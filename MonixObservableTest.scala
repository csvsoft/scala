package com.test.monix

import java.io.File

import monix.eval.Task
import monix.reactive.{MulticastStrategy, Observable}
import org.scalatest.{FunSuite, Matchers}

import scala.io.Source
import monix.execution.Scheduler.Implicits.global
import monix.reactive.subjects.ConcurrentSubject

class ObservableTest extends FunSuite with Matchers {

  test("Builder - pure/now, build from strict value"){
    val obs = Observable.now {"Hello"}
    obs.foreachL(s=> s shouldBe ("Hello")).runToFuture
    val obs2 = Observable.pure {"Hello2"}
    obs2.foreachL(s=> s shouldBe ("Hello2")).runToFuture
  }

  test("Builder - delay/eval, from non-strict value,it is evaluated upon subscription."){
    val obsEval = Observable.eval {println("HelloEval Effect");"HelloEval"}
    val obsDelay = Observable.delay {println("HelloDelay Effect");"HelloDelay"}
      obsEval.foreachL(println).runToFuture
    obsDelay.foreachL(println).runToFuture
  }


  test("fromIterable"){

    val obs = Observable.fromIterable(List(1,2,3))
    obs.foreachL(println).runToFuture
  }

  test("Suspend:Suspend side effect"){

    def obsFile(file:File)= Observable.suspend {
      val lines:Iterator[String] = Source.fromFile(file).getLines
      Observable.fromIterator(Task(lines))
    }

  }

  test("onErroHandle(With a total function)/onErrorRecover( with partial function) --  it fallbacks to an Observable emitting one specified element generated by given total function"){
    val obs = Observable(1,2,3) ++ Observable.raiseError(new Exception) ++ Observable(0)
    obs.onErrorHandle(_=>4).foreachL(println).runToFuture
  }
  test("onErrorHandleWith -- it fallbacks to an Observable generated by given total function."){
    val obs = Observable(1,2,3) ++ Observable.raiseError(new Exception) ++ Observable(0)
    obs.onErrorHandleWith(_=>Observable(4,5)).foreachL(println).runToFuture // print 1 2 3 4 5
  }

  test("subject"){
    val subject: ConcurrentSubject[Int, Int] =
      ConcurrentSubject[Int](MulticastStrategy.replay)

  }

}
